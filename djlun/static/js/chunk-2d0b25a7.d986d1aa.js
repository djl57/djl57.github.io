(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0b25a7"],{"246e":function(n,e,t){"use strict";t.r(e);var o=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("article",[t("aside",{class:n.aside?"aside":"none-aside"},[t("h1",{on:{click:n.showAside}},[n._v(n._s(n.catalog))]),t("ol",n._l(n.catalogs,function(e){return t("li",{key:e.id},[t("a",{attrs:{href:"#"+e.id}},[n._v(n._s(e.text))])])}),0)]),t("section",[t("h2",{attrs:{id:"ca1"}},[n._v("call 的模拟实现")]),t("h3",[n._v("call 的用法：")]),n._v("\n    1. "),t("pre",[t("code",[n._v(n._s(n.call1))])]),n._v("\n    2. "),t("pre",[t("code",[n._v(n._s(n.call2))])]),n._v("\n    3. "),t("pre",[t("code",[n._v(n._s(n.call3))])]),t("h3",[n._v("最终实现代码：")]),t("pre",[t("code",[n._v(n._s(n.call))])])]),t("section",[t("h2",{attrs:{id:"ca2"}},[n._v("apply 的模拟实现")]),t("h3",[n._v("apply 的用法：")]),n._v("\n    1. "),t("pre",[t("code",[n._v(n._s(n.apply1))])]),n._v("\n    2. "),t("pre",[t("code",[n._v(n._s(n.apply2))])]),t("h3",[n._v("最终实现代码：")]),t("pre",[t("code",[n._v(n._s(n.apply))])])]),t("section",[t("h2",{attrs:{id:"ca3"}},[n._v("bind 的模拟实现")]),t("h3",[n._v("bind 的用法：")]),n._v("\n    1. "),t("pre",[t("code",[n._v(n._s(n.bind1))])]),n._v("\n    2. "),t("pre",[t("code",[n._v(n._s(n.bind2))])]),n._v("\n    3. "),t("pre",[t("code",[n._v(n._s(n.bind3))])]),t("h3",[n._v("最终实现代码：")]),t("pre",[t("code",[n._v(n._s(n.bind))])])]),t("section",[t("h2",{attrs:{id:"ca4"}},[n._v("new 的模拟实现")]),t("h3",[n._v("new 的用法：")]),n._v("\n    1. "),t("pre",[t("code",[n._v(n._s(n.new1))])]),n._v("\n    2. "),t("pre",[t("code",[n._v(n._s(n.new2))])]),t("h3",[n._v("最终实现代码：")]),t("pre",[t("code",[n._v(n._s(n.news))])])]),n._m(0)])},a=[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("footer",[t("h2",[n._v("摘抄自")]),t("p",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000009257663"}},[n._v("JavaScript深入之call和apply的模拟实现")])]),t("p",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000009271416"}},[n._v("JavaScript深入之bind的模拟实现")])]),t("p",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000009286643"}},[n._v("JavaScript深入之new的模拟实现")])])])}],r={name:"",data:function(){return{createTime:"2019-03-05 13:42:00",aside:!1,catalog:"目录",catalogs:[{id:"ca1",text:"call 的模拟实现"},{id:"ca2",text:"apply 的模拟实现"},{id:"ca3",text:"bind 的模拟实现"},{id:"ca4",text:"new 的模拟实现"}],call1:"var foo = {\n  value: 1\n}\nfunction bar() {\n  console.log(this.value)\n}\nbar.call(foo) // 1",call2:"var foo = {\n  value: 1\n}\nfunction bar(name, age) {\n  console.log(name)\n  console.log(age)\n  console.log(this.value);\n}\nbar.call(foo, 'kevin', 18);\n// kevin\n// 18\n// 1",call3:"var value = 1;\nfunction bar() {\n  console.log(this.value);\n}\nbar.call(null); // 1",call:"Function.prototype.call2 = function(context) {\n  var context = context || window; // 解决传入参数为null时this指向window的情况\n  context.fn = this; // 通过this获取调用call2的函数\n  var args = []; // 要传给调用call2的函数的参数\n  for(var i = 1, len = arguments.length; i < len; i++) { // 传入参数数量不定，使用arguments解决\n    args.push('arguments[' + i + ']');\n  }\n  var result = eval('context.fn(' + args +')'); // 执行调用call2的函数，这里 args 会自动调用 Array.toString() 这个方法【let arr = [1,2,3];arr.toString() //'1,2,3'】\n  delete context.fn;\n  return result;\n}",apply1:"var x = 0; \nfunction test(){ \n\talert(this.x); \n} \nvar o = {\n  x: 1\n}; \ntest.apply(); //0 \ntest.apply(o); //1",apply2:"var x = 0; \nfunction test(name,age){ \n  console.log(this.x); \n  console.log(name); \n  console.log(age); \n} \nvar o = {\n  x: 1\n}; \nvar arr = ['djlun', 18]\ntest.apply(o, arr); \n// 1\n// djlun\n// 18",apply:"Function.prototype.apply = function (context, arr) {\n  var context = Object(context) || window;\n  context.fn = this; // 将函数设为对象的属性\n  var result;\n  if (!arr) {\n    result = context.fn();\n  } else {\n    var args = [];\n    for (var i = 0, len = arr.length; i < len; i++) { // 传入的arr赋给了函数的arguments\n      args.push('arr[' + i + ']');\n    }\n    result = eval('context.fn(' + args + ')')\n  }\n  delete context.fn\n  return result;\n}",bind1:"var foo = {\n  value: 1\n};\nfunction bar() {\n  console.log(this.value);\n}\n// bind返回了一个函数\nvar bindFoo = bar.bind(foo); \nbindFoo(); // 1",bind2:"var foo = {\n  value: 1\n};\nfunction bar(name, age) {\n  console.log(this.value);\n  console.log(name);\n  console.log(age);\n}\nvar bindFoo = bar.bind(foo, 'daisy'); // 既可以在这里传入参数\nbindFoo('18'); // 还可以在这里传入参数\n// 1\n// daisy\n// 18",bind3:"// bind 返回的函数还可以作为构造函数。此时，bind 时指定的 this 值会失效，但传入的参数依然生效。\nvar value = 2;\nvar foo = {\n  value: 1\n};\nfunction bar(name, age) {\n  this.habit = 'shopping';\n  console.log(this.value);\n  console.log(name);\n  console.log(age);\n}\nbar.prototype.friend = 'kevin';\nvar bindFoo = bar.bind(foo, 'daisy');\nvar obj = new bindFoo('18');\n// undefined   此时bind 时指定的 this 值失效（此时this指向obj，obj.value // undefined（对象没有的属性返回undefined））\n// daisy       传入的参数依然生效\n// 18          传入的参数依然生效\nconsole.log(obj.habit);  // shopping\nconsole.log(obj.friend);  // kevin",bind:'Function.prototype.bind2 = function (context) {\n  if (typeof this !== "function") {\n    throw new Error("Function.prototype.bind - what is trying to be bound is not callable");\n  } // 只有函数才可以调用这个方法。\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 1); // argument第一个参数是this的指向，后面是传入的参数，座椅取arguments第二个开始到最后的值\n  var fNOP = function () {}; // 新建一个空函数作为中转，fbound.prototype = this.prototype 改变 fbound.prototype 时会改变函数的prototype\n  var fbound = function () {\n    // 当作为构造函数时，this 指向实例，self 指向绑定函数，因为已经修改了 fbound.prototype 为 绑定函数的 prototype，此时结果为 true，当结果为 true 的时候，this 指向实例。\n    // 当作为普通函数时，this 指向 window，self 指向绑定函数，此时结果为 false，当结果为 false 的时候，this 指向绑定的 context。\n    self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments))); // 此时的arguments是bind返回的函数调用时传入的参数\n  }\n  fNOP.prototype = this.prototype;\n  fbound.prototype = new fNOP(); // 再看一下原型链\n  return fbound;\n}',new1:"function Otaku (name, age) {\n  this.name = name;\n  this.age = age;\n  this.habit = 'Games';\n}\nOtaku.prototype.strength = 60;\nOtaku.prototype.sayYourName = function () {\n  console.log('I am ' + this.name);\n}\n\nvar person = new Otaku('Kevin', '18');\nconsole.log(person.name) // Kevin\nconsole.log(person.habit) // Games // 1、实例 person 可以访问到 Otaku 构造函数里的属性\nconsole.log(person.strength) // 60 // 2、实例 person 可以访问到 Otaku.prototype 中的属性\nperson.sayYourName(); // I am Kevin",new2:"// 假如构造函数有返回值\nfunction Otaku (name, age) {\n  this.strength = 60;\n  this.age = age;\n  return { // 构造函数返回一个对象\n    name: name,\n    habit: 'Games'\n  }\n}\nvar person = new Otaku('Kevin', '18');\nconsole.log(person.name) // Kevin // *实例 person 中只能访问返回的对象中的属性\nconsole.log(person.habit) // Games\nconsole.log(person.strength) // undefined\nconsole.log(person.age) // undefined",news:"function objectFactory() { // 第一个参数为构造函数，其他参数为传入构造函数的参数\n  var obj = new Object(), // 新建一个对象\n      Constructor = [].shift.call(arguments); // 删除arguments第一个元素，并将这个元素返回\n  obj.__proto__ = Constructor.prototype; // 将obj的原型设为构造函数的原型，就可以访问构造函数原型中的属性\n  var ret = Constructor.apply(obj, arguments); // 将obj设为构造函数的this（这样 obj 就可以访问到构造函数中的属性），并将删除了第一个元素的arguments当参数传入\n  return typeof ret === 'object' ? ret : obj; // 还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果*没有*，我们该返回什么就返回什么。\n};"}},components:{},mounted:function(){},computed:{},methods:{showAside:function(){this.aside=!this.aside,this.aside?this.catalog="隐藏":this.catalog="目录"},hideCatalog:function(){this.aside=!1,this.catalog="目录"}}},s=r,i=t("2877"),l=Object(i["a"])(s,o,a,!1,null,"9af10064",null);e["default"]=l.exports}}]);