(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d22d215"],{f5d4:function(n,e,t){"use strict";t.r(e);var a=function(){var n=this,e=n.$createElement;n._self._c;return n._m(0)},s=[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("table",[t("tr",[t("th",[n._v("别名")]),t("th",[n._v("目录")])]),t("tr",[t("td",[n._v("~ 或 @")]),t("td",[n._v("src目录")])]),t("tr",[t("td",[n._v("~~ 或 @@")]),t("td",[n._v("根目录")])])]),t("p",[n._v("默认情况下，src目录和根目录相同")]),n._v("\n\n# 路由\n"),n._v("\n\n例如:\n``` js\n"),n._v("\n```\n## 基础路由\n假设 pages 的目录结构如下：\n``` \npages/\n--| user/\n-----| index.vue\n-----| one.vue\n--| index.vue\n```\n那么，Nuxt.js 自动生成的路由配置如下：\n``` js\nrouter: {\n  routes: [\n    {\n      name: 'index',\n      path: '/',\n      component: 'pages/index.vue'\n    },\n    {\n      name: 'user',\n      path: '/user',\n      component: 'pages/user/index.vue'\n    },\n    {\n      name: 'user-one',\n      path: '/user/one',\n      component: 'pages/user/one.vue'\n    }\n  ]\n}\n```\n## 动态路由\n在 Nuxt.js 里面定义带参数的动态路由，需要创建对应的以下划线作为前缀的 Vue 文件 或 目录。\n\n以下目录结构：\n``` js\npages/\n--| _slug/\n-----| comments.vue\n-----| index.vue\n--| users/\n-----| _id.vue\n--| index.vue\nNuxt.js 生成对应的路由配置表为：\n```\n``` js\nrouter: {\n  routes: [\n    {\n      name: 'index',\n      path: '/',\n      component: 'pages/index.vue'\n    },\n    {\n      name: 'users-id',\n      path: '/users/:id?',\n      component: 'pages/users/_id.vue'\n    },\n    {\n      name: 'slug',\n      path: '/:slug',\n      component: 'pages/_slug/index.vue'\n    },\n    {\n      name: 'slug-comments',\n      path: '/:slug/comments',\n      component: 'pages/_slug/comments.vue'\n    }\n  ]\n}\n```\n你会发现名称为 users-id 的路由路径带有 :id? 参数，表示该路由是可选的。如果你想将它设置为必选的路由，需要在 users/_id 目录内创建一个 index.vue 文件。\n\n## 路由参数校验\nNuxt.js 可以让你在动态路由组件中定义参数校验方法。\n\n举个例子： pages/users/_id.vue\n``` js\nexport default {\n  validate ({ params }) {\n    // 必须是number类型\n    return /^\\d+$/.test(params.id)\n  }\n}\n```\n如果校验方法返回的值不为 true或Promise中resolve 解析为false或抛出Error ， Nuxt.js 将自动加载显示 404 错误页面或 500 错误页面。\n\n## 嵌套路由\n你可以通过 vue-router 的子路由创建 Nuxt.js 应用的嵌套路由。\n\n创建内嵌子路由，你需要添加一个 Vue 文件，同时添加一个与该文件同名的目录用来存放子视图组件。\n\n"),n._v("\n\n假设文件结构如：\n``` js\npages/\n--| users/\n-----| _id.vue\n-----| index.vue\n--| users.vue\n```\nNuxt.js 自动生成的路由配置如下：\n``` js\nrouter: {\n  routes: [\n    {\n      path: '/users',\n      component: 'pages/users.vue',\n      children: [\n        {\n          path: '',\n          component: 'pages/users/index.vue',\n          name: 'users'\n        },\n        {\n          path: ':id',\n          component: 'pages/users/_id.vue',\n          name: 'users-id'\n        }\n      ]\n    }\n  ]\n}\n```\n## 动态嵌套路由\n这个应用场景比较少见，但是 Nuxt.js 仍然支持：在动态路由下配置动态子路由。\n\n假设文件结构如下：\n``` js\npages/\n--| _category/\n-----| _subCategory/\n--------| _id.vue\n--------| index.vue\n-----| _subCategory.vue\n-----| index.vue\n--| _category.vue\n--| index.vue\n```\nNuxt.js 自动生成的路由配置如下：\n``` js\nrouter: {\n  routes: [\n    {\n      path: '/',\n      component: 'pages/index.vue',\n      name: 'index'\n    },\n    {\n      path: '/:category',\n      component: 'pages/_category.vue',\n      children: [\n        {\n          path: '',\n          component: 'pages/_category/index.vue',\n          name: 'category'\n        },\n        {\n          path: ':subCategory',\n          component: 'pages/_category/_subCategory.vue',\n          children: [\n            {\n              path: '',\n              component: 'pages/_category/_subCategory/index.vue',\n              name: 'category-subCategory'\n            },\n            {\n              path: ':id',\n              component: 'pages/_category/_subCategory/_id.vue',\n              name: 'category-subCategory-id'\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n```\n## SPA fallback\n您也可以为动态路由启用SPA fallback。在使用mode:'spa'模式下，Nuxt.js将输出一个与index.html相同的额外文件。如果没有文件匹配，大多数静态托管服务可以配置为使用SPA模板。生成文件不包含头信息或任何HTML，但它仍将解析并加载API中的数据。\n\n我们在nuxt.config.js文件中启用它：\n``` js\nexport default {\n  generate: {\n    fallback: true, // if you want to use '404.html'\n    fallback: 'my-fallback/file.html' // if your hosting needs a custom location\n  }\n}\n```\n# 过渡动效\n"),n._v("\n\n## 全局过渡动效设置\nNuxt.js 默认使用的过渡效果名称为 page\n\n如果想让每一个页面的切换都有淡出 (fade) 效果，我们需要创建一个所有路由共用的 CSS 文件。所以我们可以在 assets/ 目录下创建这个文件：\n\n在全局样式文件 assets/main.css 里添加一下样式：\n``` css\n.page-enter-active, .page-leave-active {\n  transition: opacity .5s;\n}\n.page-enter, .page-leave-active {\n  opacity: 0;\n}\n```\n然后添加到 nuxt.config.js 文件中：\n``` js\nmodule.exports = {\n  css: [\n    'assets/main.css'\n  ]\n}\n```\n\n## 页面过渡动效设置\n如果想给某个页面自定义过渡特效的话，只要在该页面组件中配置 transition 字段即可：\n\n在全局样式 assets/main.css 中添加一下内容：\n``` css\n.test-enter-active, .test-leave-active {\n  transition: opacity .5s;\n}\n.test-enter, .test-leave-active {\n  opacity: 0;\n}\n```\n然后我们将页面组件中的 transition 属性的值设置为 test 即可：\n``` js\nexport default {\n  transition: 'test'\n}\n```\n\n# 中间件\n中间件允许您定义一个自定义函数运行在一个页面或一组页面渲染之前。\n\n每一个中间件应放置在 middleware/ 目录。文件名的名称将成为中间件名称(middleware/auth.js将成为 auth 中间件)。\n\n一个中间件接收 context 作为第一个参数：\n``` js\nexport default function (context) {\n  context.userAgent = process.server ? context.req.headers['user-agent'] : navigator.userAgent\n}\n```\n中间件执行流程顺序：\n\n1. nuxt.config.js\n2. 匹配布局\n3. 匹配页面\n\n中间件可以异步执行,只需要返回一个 Promise 或使用第2个 callback 作为第一个参数：\n\nmiddleware/stats.js\n``` js\nimport axios from 'axios'\n\nexport default function ({ route }) {\n  return axios.post('http://my-stats-api.com', {\n    url: route.fullPath\n  })\n}\n```\n然后在你的 nuxt.config.js 、 layouts 或者 pages 中使用中间件:\n\nnuxt.config.js\n``` js\nmodule.exports = {\n  router: {\n    middleware: 'stats'\n  }\n}\n```\nstats 中间件将在每个路由改变时被调用。\n\n# 布局\nNuxt.js 允许你扩展默认的布局，或在 layout 目录下创建自定义的布局。\n\n## 默认布局\n可通过添加 layouts/default.vue 文件来扩展应用的默认布局。\n\n"),n._v("\n\n默认布局的源码如下：\n``` html\n"),n._v("\n```\n## 错误页面\n你可以通过编辑 layouts/error.vue 文件来定制化错误页面.\n\n"),n._v("\n\n默认的错误页面源码在 [这里](https://github.com/nuxt/nuxt.js/blob/dev/packages/vue-app/template/components/nuxt-error.vue).\n\n举一个个性化错误页面的例子 layouts/error.vue:\n``` html\n"),n._v("\n```\n``` js\n"),n._v("\n```\n## 个性化布局\nlayouts 根目录下的所有文件都属于个性化布局文件，可以在页面组件中利用 layout 属性来引用。\n\n"),n._v("\n\n举个例子 layouts/blog.vue:\n``` js\n"),n._v("\n```\n在 pages/posts.vue 里， 可以指定页面组件使用 blog 布局。\n``` js\n"),n._v("\n```\n\n## 页面\n页面组件实际上是 Vue 组件，只不过 Nuxt.js 为这些组件添加了一些特殊的配置项（对应 Nuxt.js 提供的功能特性）以便你能快速开发通用应用。\n``` js\n"),n._v("\nexport default {\n  asyncData (context) {\n    // called every time before loading the component\n    return { name: 'World' }\n  },\n  fetch () {\n    // The fetch method is used to fill the store before rendering the page\n  },\n  head () {\n    // Set Meta Tags for this Page\n  },\n  // and more functionality to discover\n  ...\n}\n"),n._v("\n```\nNuxt.js 为页面提供的特殊配置项：\n\n|属性名|\t描述|\n|--|--|\n|asyncData|\t最重要的一个键, 支持 异步数据处理，另外该方法的第一个参数为当前页面组件的 上下文对象。|\n|fetch|\t与 asyncData 方法类似，用于在渲染页面之前获取数据填充应用的状态树（store）。不同的是 fetch 方法不会设置组件的数据。详情请参考 关于fetch方法的文档。|\n|head|\t配置当前页面的 Meta 标签, 详情参考 页面头部配置API。|\n|layout|\t指定当前页面使用的布局（layouts 根目录下的布局文件）。详情请参考 关于 布局 的文档。|\n|loading|\t如果设置为false，则阻止页面自动调用this.$nuxt.$loading.finish()和this.$nuxt.$loading.start(),您可以手动控制它,请看例子,仅适用于在nuxt.config.js中设置loading的情况下。请参考API配置 loading 文档。|\n|transition|\t指定页面切换的过渡动效, 详情请参考 页面过渡动效。|\n|scrollToTop|\t布尔值，默认: false。 用于判定渲染页面前是否需要将当前页面滚动至顶部。这个配置用于 嵌套路由的应用场景。|\n|validate|\t校验方法用于校验 动态路由的参数。|\n|middleware|\t指定页面的中间件，中间件会在页面渲染之前被调用， 请参考 路由中间件。|\n\n## 默认 Meta 标签\nNuxt.js 允许你在 nuxt.config.js 里定义应用所需的所有默认 meta 标签，在 head 字段里配置就可以了：\n\n一个使用自定义 viewport 和 谷歌字体 的配置示例：\n``` js\nhead: {\n  meta: [\n    { charset: 'utf-8' },\n    { name: 'viewport', content: 'width=device-width, initial-scale=1' }\n  ],\n  link: [\n    { rel: 'stylesheet', href: 'https://fonts.googleapis.com/css?family=Roboto' }\n  ]\n}\n```\n\n## asyncData 方法\nasyncData方法会在组件（限于页面组件）每次加载之前被调用。它可以在服务端或路由更新之前被调用。 在这个方法被调用的时候，第一个参数被设定为当前页面的上下文对象，你可以利用 asyncData方法来获取数据，Nuxt.js 会将 asyncData 返回的数据融合组件 data 方法返回的数据一并返回给当前组件。\n\n注意：由于asyncData方法是在组件 初始化 前被调用的，所以在方法内是没有办法通过 this 来引用组件的实例对象。\n  ")])}],o=t("cebc"),u=t("2f62"),r={name:"",data:function(){return{aside:!1,catalog:"目录",catalogs:[{id:"ca1",text:"别名"},{id:"ca2",text:"路由",children:[{id:"ca2-ro1",text:"基础路由"},{id:"ca2-ro2",text:"动态路由"},{id:"ca2-ro2",text:"路由参数校验"},{id:"ca2-ro2",text:"嵌套路由"},{id:"ca2-ro2",text:"动态嵌套路由"}]},{id:"ca3",text:"过渡动效",children:[{id:"ca3-ro1",text:"全局过渡动效设置"},{id:"ca3-ro2",text:"页面过渡动效设置"}]},{id:"ca4",text:"中间件"},{id:"ca5",text:"布局"},{id:"ca1",text:"别名"},{id:"ca1",text:"别名"},{id:"ca1",text:"别名"},{id:"ca1",text:"别名"},{id:"ca1",text:"别名"},{id:"ca1",text:"别名"}]}},components:{},mounted:function(){this.getList()},computed:Object(o["a"])({},Object(u["b"])(["firstLevel","secondLevel","articleTitle"])),methods:{getList:function(){this.$store.dispatch("GetList")}}},i=r,c=t("2877"),d=Object(c["a"])(i,a,s,!1,null,"22aa5adb",null);e["default"]=d.exports}}]);