(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d216065"],{c167:function(e,t,n){"use strict";n.r(t);var o=function(){var e=this,t=e.$createElement;e._self._c;return e._m(0)},s=[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("article",[n("header",[n("h1",[e._v("js 性能测试工具")])]),n("main",[n("section",[n("h2",[e._v("前置知识")]),n("section",[n("h3",[e._v("数据类型：")]),n("div",{staticClass:"bold"},[e._v("原始类型")]),n("p",[e._v("数值、字符串、布尔值、null、undefined")]),n("div",{staticClass:"bold"},[e._v("引用类型")]),n("p",[e._v("数组、对象、函数")])]),n("section",[n("h3",[e._v("存储形式：")]),n("div",{staticClass:"bold"},[e._v("原始类型")]),n("p",[e._v("存储的是对象的实际数据。")]),n("div",{staticClass:"bold"},[e._v("引用类型")]),n("p",[e._v("存储的是对象的引用地址（对象的实际内容单独存放，为了减少数据开销通常存放在内存中）。")])])]),n("section",[n("h2",[e._v("什么是克隆？")]),n("p",[e._v("克隆只针对对象、数组、函数等复杂数据。")])]),n("section",[n("h2",[e._v("浅克隆")]),n("section",[n("h3",[e._v("概念")]),n("p",[e._v("当数组或对象没有嵌套数组或对象，那么浅克隆就可以实现对象和数组的克隆，并且克隆对象不会和原对象互相影响。")]),n("p",[e._v("但是当嵌套了数组或对象时，浅克隆克隆地并不彻底，克隆对象和原对象会互相影响。")])]),n("section",[n("h3",[e._v("实现")]),n("div",{staticClass:"bold"},[e._v("数组浅克隆：")]),n("code",[e._v("let copy = arr.slice()")]),n("br"),n("code",[e._v("let copy = arr.concat()")]),n("br"),n("code",[e._v("let copy = [...arr]")]),n("div",{staticClass:"bold"},[e._v("对象浅克隆：")]),n("code",[e._v("let copy = Object.assign({}, obj)")]),n("br"),n("code",[e._v("let copy = {...obj}")]),n("div",{staticClass:"bold"},[e._v("通用浅克隆实现：")]),n("pre",[n("code",[e._v("\nconst shallowClone = obj => {\n  if (typeof obj !== 'object') return obj;\n  var newObj = obj instanceof Array ? [] : {};\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      newObj[key] = obj[key];\n    }\n  }\n  return newObj;\n}\n// es6\nconst shallowClone = obj => {\n  if (typeof obj !== 'object') return obj;\n  return [...obj]\n}         ")])])])]),n("section",[n("h2",[e._v("深克隆")]),n("section",[n("h3",[e._v("概念")]),n("p",[e._v("完全的拷贝一个对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。")])]),n("section",[n("h3",[e._v("实现")]),n("div",{staticClass:"bold"},[e._v("使用递归：")]),n("pre",[n("code",[e._v("\nlet deepClone = obj => {\n  if (typeof obj !== 'object') return obj;\n  let newObj = obj instanceof Array ? [] : {};\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      newObj[key] = deepClone(obj[key])\n    }\n  }\n  return newObj;\n}")])]),n("div",{staticClass:"bold"},[e._v("使用递归的性能问题：")]),n("p",[e._v("尽管使用深拷贝会完全的克隆一个新对象，不会产生副作用，但是深拷贝因为使用递归，性能会不如浅拷贝，在开发中，还是要根据实际情况进行选择。")]),n("div",{staticClass:"bold"},[e._v("使用JSON（不能克隆函数）：")]),n("code",[e._v("let copy = JSON.parse(JSON.stringify(arr))")]),n("div",{staticClass:"bold"},[e._v("当克隆的对象里嵌套了函数时：")]),n("code",[e._v("\n            var arr = [ function() {return 1},{ b:function() {return 2} } ]"),n("br"),e._v("\n            var copy = JSON.parse(JSON.stringify(arr)) // [ null, {} ]\n          ")])])])]),n("footer",[n("h2",[e._v("摘抄自：")]),n("p",[n("a",{attrs:{href:"https://www.cnblogs.com/diantao/p/5271652.html"}},[e._v("js简易函数性能测试器")])]),n("p",[n("a",{attrs:{href:"https://blog.csdn.net/sinat_17775997/article/details/70482279"}},[e._v("JS浅克隆与深克隆")])]),n("p",[n("a",{attrs:{href:"https://segmentfault.com/a/1190000010150234"}},[e._v("vaScript专题之深浅拷贝")])])])])}],r={name:"",data:function(){return{}},computed:{}},a=r,c=n("2877"),i=Object(c["a"])(a,o,s,!1,null,null,null);t["default"]=i.exports}}]);