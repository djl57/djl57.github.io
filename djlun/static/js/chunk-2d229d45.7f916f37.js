(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d229d45"],{deb0:function(n,e,s){"use strict";s.r(e);var o=function(){var n=this,e=n.$createElement,s=n._self._c||e;return s("article",[s("p",[n._v("官方推荐工具")]),s("h2",[n._v("封装mongoDB的准备工作")]),s("p",[n._v("市场上已经有很多封装mongoDB的模块，为什么还要自己封装？（1）更小；（2）速度更快；（3）更灵活")]),s("h3",[n._v("es5的类、静态方法以及继承")]),s("p",[n._v("1、es5中定义类是通过构造函数来实现的。")]),s("pre",[s("code",[n._v(n._s(n.es5))])]),s("p",[n._v("构造函数里面的方法和属性 和 构造函数原型链上的属性和方法 都属于实例的属性和方法，也就是说，\n    想要调用这些属性和方法必须先实例化Person类，即实例化构造函数【const person = new Person();\n    p.run();p.work()】")]),s("p",[n._v("3、而静态方法是直接绑定在构造函数上，直接通过Person.setName()来调用。")]),s("div",{staticClass:"bols"},[n._v("构造函数里面的方法和属性 和 构造函数原型链上的方法和属性 有什么区别？")]),s("p",[n._v("原型链上的属性和方法可以被多个实例共享")]),s("p",[n._v("2、es5中的继承一般是通过原型链 + 对象冒充的组合继承模式")]),s("pre",[s("code",[n._v(n._s(n.jicheng5))])]),s("div",{staticClass:"bold"},[n._v("原型链和对象冒充的优缺点？")]),s("p",[n._v("（1）对象冒充继承缺点：没法继承原型链上的属性和方法。")]),s("p",[n._v("（2）原型链继承优点：可以继承构造函数里面和原型链上的属性和方法。")]),s("p",[n._v("（3）原型链继承缺点：实例化子类的时候没法给父类传参。【如果只有原型链继承，通过实例调用run方法时的this.name和\n    this.age是undefined】")]),s("h3",[n._v("es6的类、静态方法以及继承")]),s("p",[n._v("1、es6中定义类是通过class的方法来实现的。")]),s("pre",[s("code",[n._v(n._s(n.es6))])]),s("p",[n._v("2、es6中的继承是通过extends来实现的")]),s("pre",[s("code",[n._v(n._s(n.jicheng6))])]),s("p",[n._v("3、es6中的静态方法是通过static关键词来实现的")]),s("pre",[s("code",[n._v(n._s(n.static6))])]),s("h3",[n._v("es6中的单例模式")]),s("div",{staticClass:"bold"},[n._v("什么是单例模式？")]),s("p",[n._v("无论创建多少个实例，类中的构造函数只执行一次（即new只执行一次）。")]),s("pre",[s("code",[n._v(n._s(n.single6))])])])},t=[],a={name:"mongoDBCompassCommunity",data:function(){return{createTime:"2019-03-14 16:56:00",es5:"function Person(name, age) {\n  // 构造函数里面的方法和属性\n  this.name = name\n  this.age = age\n  this.run = function() {\n    console.log(this.name + '-----' + this.age)\n  }\n}\n// 构造函数原型链上的属性和方法\nPerson.prototype.sex = '男'\nPerson.prototype.work = function() {\n  console.log(this.name + this.age + this.sex)\n}\n// 构造函数的静态方法\nPerson.setName = function() {\n  console.log('静态方法')\n}",jicheng5:"// 同样是上面那个Person类\n// 现在有一个Web想要继承Person\n\nfunction Web(name, age) {\n  Person.call(this, name, age) // 对象冒充实现继承（没有这个继承不能给父类传值）\n}\nWeb.prototype = new Person(); // 原型链实现继承（没有这个不能继承原型链上的属性和方法）\n",es6:"class Person {\n  constructor(name, age) { // 类的构造函数，实例化类的时候会执行构造函数，然后this._name和this._age有值，调用getName和setName就有值了\n    // 表示类里面的属性\n    this._name = name\n    this._age = age\n  }\n  getName() {\n    console.log(this._name)\n  }\n  setName(name) {\n    this._name = name\n  }\n}\n\nlet p = new Person('djlun', 18)",jicheng6:"//还是上面那个Person class\n// 现在有一个Web要继承Person类\nclass Web extends Person() {\n  constructor(name, age, sex) {\n    super(name, age) // 这里实现了实例化子类的时候给父类传参\n    this._sex = sex\n  }\n  print() {\n    console.log(this._sex)\n  }\n}\n\nlet w = new Web('djlun', 18, '女')",static6:"class Person {\n  constructor(name) {\n    this._name = name // 属性\n  }\n  run() { // 实例方法\n    console.log(this._name)\n  }\n  static work() { // 静态方法\n    console.log('这是es6中的静态方法')\n  }\n}\n// 也可以像es5一样\nPerson.instance = '这是一个静态方法的属性' // 通过Person.instance调用\n\n// 静态方法调用\nPerson.work()",single6:"class Db {\n  static getInstance() {\n    if(!Db.instance) { // 如果这个静态方法里面没有这个Db的实例（即还没有new过，构造函数还没有执行过）\n      Db.instance = new Db() // 静态属性 = Db对象 ，即进行一次实例化\n    }\n    return Db.instance // 如果有实例，直接返回当前的静态实例\n  }\n  constructor() {\n    console.log('实例化的时候会触发')\n    this.connect()\n  }\n  connect() {\n    console.log('连接数据库')\n  }\n  find() {\n    console.log('查询数据库')\n  }\n}\n\nlet myDB = Db.getInstance() // 这时创建实例是调用类的静态方法，判断实例是否已经存在，这样就实现就执行一次实例化"}},components:{},mounted:function(){},computed:{},methods:{}},c=a,i=s("2877"),r=Object(i["a"])(c,o,t,!1,null,"23dba204",null);e["default"]=r.exports}}]);